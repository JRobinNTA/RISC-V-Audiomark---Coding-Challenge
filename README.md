## RISC-V Audiomark Coding Challenge Solution

##### Project Structure

- **"Coding Challenge - RISC-V Audiomark.md"** The coding challenge question
- **src/** Directory to contain the source code and the benchmark harness
- **final.asm** Disassembled assembly code generated by the compiler
- **m5out/** Statistics generated by the gem5 simulator

To verify the results update the gem5 **path** in the given Makefile
Before that make sure you built gem5 for RISCV ISA

```bash
make run
```
Expected output

```bash
Cycles ref: 59689
Verify RVV: OK (max diff = 0)
Cycles RVV: 3108
```

> Note :
- Performance was measured using the gem5 simulator (O3CPU, Out-of-Order execution model) to simulate a high-performance RISC-V core.
- The gem5 emulator used a default VLEN of 256 bits width and ELEN of 64 bits

---

### The Solution

```C
void q15_axpy_rvv(const int16_t *a, const int16_t *b,
                  int16_t *y, int n, int16_t alpha)
{
    size_t vl;
    for (; n > 0; n -= vl) {
        // Set vl based on input size 16-bit and input LMUL as m4
        vl = __riscv_vsetvl_e16m4(n); 

        // Load inputs LMUL m4
        vint16m4_t va = __riscv_vle16_v_i16m4(a, vl);
        vint16m4_t vb = __riscv_vle16_v_i16m4(b, vl);

        // Widen Multiply Input m4 to Output m8
        vint32m8_t v_acc = __riscv_vwmul_vx_i32m8(vb, alpha, vl);

        // Widen Add Input m4 + Acc m8 and store to Acc m8
        v_acc = __riscv_vwadd_wv_i32m8(v_acc, va, vl);

        // Narrow and Saturate Acc m8 to Output m4
        vint16m4_t vy = __riscv_vnclip_wx_i16m4(v_acc, 0, vl);

        // Store LMUL m4
        __riscv_vse16_v_i16m4(y, vy, vl);

        a += vl; b += vl; y += vl;
    }
}
```
---
#### Documentation and reasoning

```C
    size_t vl;
    vl = __riscv_vsetvl_e16m4(n);
```
Dynamically set the vl length for 16 bit integers with LMUL = 4

```C
    vint16m4_t va = __riscv_vle16_v_i16m4(a, vl);
    vint16m4_t vb = __riscv_vle16_v_i16m4(b, vl);
```
Then load up the elements into the respective vectors based on the vl value

```C
    vint32m8_t v_acc = __riscv_vwmul_vx_i32m8(vb, alpha, vl);
```
Widen vb and multiply with alpha, since both vb and alpha are 16 bit we need to widen the product into a 32 bit long container called v_acc, whose EMUL is 8

Since alpha is scalar and vb is vector the vx variant of the widen multiply was used

```C
    v_acc = __riscv_vwadd_wv_i32m8(v_acc, va, vl);
```
Widen va and add with v_acc

Since v_acc is 32 bit vector and va is 16 bit vector the wv variant of the vwadd instruction was used

```C
    vint16m4_t vy = __riscv_vnclip_wx_i16m4(v_acc, 0, vl);
```

Narrow and saturate v_acc to 16 bit long vy

Instead of manually checking for saturation and casting vnclip performs the shifting, narrowing and casting in a single hardware instruction

```C
    __riscv_vse16_v_i16m4(y, vy, vl);
```
Store the vectors into y

> On Average around **19.2 times** speed up was observed between the iterative and the vector approach
